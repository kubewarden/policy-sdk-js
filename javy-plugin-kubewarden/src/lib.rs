use javy_plugin_api::{
    javy::{
        quickjs::{prelude::Func, Error, Object},
        Runtime,
    },
    javy_plugin, Config,
};

wit_bindgen::generate!({
    world: "kubewarden-plugin",
    generate_all
});

fn config() -> Config {
    let mut config = Config::default();
    config.text_encoding(true).javy_stream_io(true);

    config
}

fn modify_runtime(runtime: Runtime) -> Runtime {
    runtime
        .context()
        .with(|ctx| {
            ctx.globals().set(
                "policyAction",
                Func::from(|| {
                    let args = std::env::args().collect::<Vec<String>>();
                    if args.len() != 2 {
                        // TODO: move to Error::UserData when javy upgrades to latest version of rquickjs
                        return Err(Error::Unknown);
                    }
                    Ok(args[1].clone())
                }),
            )
        })
        .unwrap();
    runtime
        .context()
        .with(|ctx| {
            ctx.globals().set(
                "__hostCall",
                Func::from(|binding: String, ns: String, op: String, msg: Object| {
                    let msg = msg
                        .as_array_buffer()
                        .and_then(|ab| ab.as_bytes())
                        .ok_or(Error::Unknown)?; // TODO: move to Error::UserData when javy upgrades to latest version of rquickjs

                    // javy-plugin requires to build our plugin using the wasip2 target, which in turns forces the usage of the
                    // WebAssembly component model. However, at this time, the javy compiler (v7.0.0) produces wasip1 modules instead of
                    // wasm components.
                    //
                    // That means that inside of policy-evaluator we cannot use wasmtime's `bindgen` feature to generate the host
                    // bindings. The code generation works only when dealing with a wasm component.
                    //
                    // The signatures of WIT functions are pretty elaborated, they are too complex to be implemented manually.
                    // Hence, we have to define a WIT interface that relies on simple native WebAssembly types, which is
                    // exactly what waPC does.
                    //
                    // The WIT interface has to be defined using `i32` types only, which is actually what wasip1 uses under the hood
                    // when translating fancy Rust types like `*const u8` and `usize`.
                    //
                    // Here we're actually using the guest code generated by wit-bindgen, hence we
                    // have to stick with the final "i32-only" signature. That's why we're doing
                    // all these conversion to u32.
                    let successful = crate::kubewarden::javy::host::call(
                        binding.as_ptr() as u32,
                        binding.len() as u32,
                        ns.as_ptr() as u32,
                        ns.len() as u32,
                        op.as_ptr() as u32,
                        op.len() as u32,
                        msg.as_ptr() as u32,
                        msg.len() as u32,
                    );

                    Ok::<bool, Error>(successful == 0)
                }),
            )
        })
        .unwrap();
    runtime
}

struct Component;

// Dynamically linked modules will use `my_javy_plugin_v1` as the import
// namespace.
javy_plugin!("kubewarden-plugin", Component, config, modify_runtime);

export!(Component);
